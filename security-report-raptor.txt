security-report-raptor.txt — HeliumTS Security Review (generated by Raptor mini)

Project: heliumts
Date: 2026-02-08
Reviewer: GitHub Copilot (Raptor mini (Preview))

Summary
-------
A repository-wide security review was completed. The codebase shows many good practices (HMAC tokens, timing-safe compares, rate limiting, env filtering for client). However, I found several high- and medium-severity issues that should be addressed before production deployment. The most critical items are: directory traversal in static file serving, unbounded request/message sizes (DoS risk), token leakage via URL query, and error leakage to clients.

High severity (fix immediately)
--------------------------------
1) Directory traversal when serving static files
- Files: src/server/prodServer.ts (static file serving logic)
- Problem: path.join(staticDir, cleanUrl) can resolve outside staticDir (e.g., /../../etc/passwd).
- Impact: Arbitrary file reads from the host.
- Fix: Resolve and validate path against staticDir (e.g., const resolved = path.resolve(staticDir, '.' + cleanUrl); if (!resolved.startsWith(path.resolve(staticDir) + path.sep)) { block }).

2) Unbounded request and WebSocket message sizes → DoS
- Files: src/server/httpRouter.ts (readBody), WebSocket handlers in src/server/prodServer.ts, src/server/rpcRegistry.ts
- Problem: No enforced max body size for HTTP or max message size for WS; entire payloads are buffered and decoded.
- Impact: Memory/CPU exhaustion and decompression/processing DoS.
- Fix:
  - Enforce configurable maximum body bytes for HTTP POST (Content-Length check & streaming limit).
  - For WebSocket messages, reject messages above a configured limit before decoding.
  - Add tests and configuration (defaults: e.g., 1–2 MB).

3) Connection token in URL query (token leakage)
- Files: src/client/rpcClient.ts and src/server/prodServer.ts
- Problem: Tokens are added to WebSocket URL as ?token=... → leakable via Referer, logs, proxies.
- Impact: Short-lived tokens can be discovered and reused.
- Fix:
  - Prefer secure cookie (SameSite, HttpOnly) or WebSocket subprotocol (Sec-WebSocket-Protocol) to transmit token.
  - If keeping query param, ensure very short TTL + strict monitoring and document risk.

4) Decompression / compression handling risks
- Files: src/client/rpcClient.ts (gzip detection) and WS compression config in src/server/prodServer.ts
- Problem: Decompressing large or crafted compressed messages can be exploited (zip bombs).
- Fix:
  - Set strict decompression limits; disable permessage-deflate in hostile environments or ensure safe inflator limits. Check size after decompression.

5) Internal error details returned to RPC clients
- Files: src/server/rpcRegistry.ts
- Problem: Server returns err?.message directly to clients.
- Impact: Sensitive internal info (DB errors, file paths, secrets) can leak to clients.
- Fix:
  - Return a generic message ("Server error") to clients; log full error server-side. Provide a safe error wrapper type for controlled exposure.

Medium severity (should fix)
-----------------------------
1) Per-process random HELIUM_SECRET default
- File: src/server/security.ts
- Problem: Uses crypto.randomBytes(32) if HELIUM_SECRET not set: tokens won't verify across multiple instances in a cluster.
- Fix: Require HELIUM_SECRET in production or warn strongly. Document requirement.

2) GET /__helium__/refresh-token is unauthenticated
- Files: src/server/prodServer.ts, src/client/rpcClient.ts
- Problem: Unauthenticated GET returns tokens. While same-origin mitigates direct read, better to harden.
- Fix: Consider POST, origin/referrer checks, or cookie-based flows.

3) Missing security headers for static responses
- File: src/server/prodServer.ts
- Problem: No default Content-Security-Policy, X-Frame-Options, X-Content-Type-Options, etc.
- Fix: Add configurable default security headers or provide middleware to set them.

4) RPC message validation
- File: src/server/rpcRegistry.ts
- Problem: No validation of RPC message shape or count of batched requests.
- Fix: Validate id types, method name length/characters, and cap batch sizes.

5) readBody doesn't respect Content-Length pre-check
- File: src/server/httpRouter.ts
- Problem: No early rejection if Content-Length header exceeds allowed limit.
- Fix: Pre-check Content-Length and stream-limit enforcement.

Low severity / hardening
------------------------
- Redact sensitive fields in logs (avoid logging full token values).
- Add dependency vulnerability scanning and CI checks (Dependabot / npm audit).
- Add tests for traversal, oversized bodies, and token handling.
- Consider explicit defaults for trustProxyDepth (document security implications).

Concrete remediation snippets
----------------------------
(Short examples — adapt safe config values, add tests.)

1) Static path normalization
const resolvedStaticDir = path.resolve(staticDir);
const resolved = path.resolve(resolvedStaticDir, '.' + cleanUrl || '/');
if (!resolved.startsWith(resolvedStaticDir + path.sep) && resolved !== resolvedStaticDir) {
  filePath = path.join(staticDir, "index.html");
  is404 = true;
} else {
  filePath = resolved;
}

2) HTTP body max bytes
const MAX_BODY_BYTES = 1_000_000;
function readBody(req) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    let size = 0;
    req.on('data', (chunk) => {
      size += chunk.length;
      if (size > MAX_BODY_BYTES) {
        req.destroy();
        reject(new Error('Request entity too large'));
      } else {
        chunks.push(chunk);
      }
    });
    ...
  });
}

3) Use subprotocol header for socket token
- Client:
const token = await fetchFreshToken();
const ws = token ? new WebSocket(url, token) : new WebSocket(url);
- Server upgrade:
const token = req.headers['sec-websocket-protocol'];
if (!token || !verifyConnectionToken(token as string)) { ... }

4) Return generic RPC errors:
catch (err: any) {
  log('error', 'Method handler failed', err);
  return { id: req.id, ok: false, stats: this.getStats(socket), error: 'Server error' };
}

Testing & CI
------------
- Add tests for:
  - Directory traversal attempts.
  - Oversized HTTP bodies and too-large WS messages.
  - Token verification across multiple instances (with/without HELIUM_SECRET).
- Add security linting in CI and dependency scanning.

Next steps & offers
-------------------
- Priority: fix directory traversal, implement body/message size limits, stop token in query, and sanitize RPC errors.
- I can prepare PR-ready patches for the high-severity fixes (static path validation, HTTP body limit, WS token via subprotocol, generic RPC errors) and associated tests if you want. Would you like me to create the patches now?

End of report
