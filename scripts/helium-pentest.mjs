#!/usr/bin/env node

/**
 * HeliumTS application security smoke test (safe pentest)
 *
 * Scope:
 * - Sensitive file exposure checks
 * - Token endpoint hardening checks
 * - RPC token enforcement checks
 * - Basic client bundle secret scanning
 *
 * Usage:
 *   node scripts/helium-pentest.mjs --url http://localhost:3000
 *   node scripts/helium-pentest.mjs --url https://staging.example.com --timeout 12000 --max-js 12
 */

const DEFAULT_TIMEOUT_MS = 10_000;
const DEFAULT_MAX_JS = 10;

const args = parseArgs(process.argv.slice(2));

if (args.help || !args.url) {
    printUsage();
    process.exit(args.help ? 0 : 1);
}

const baseUrl = normalizeBaseUrl(args.url);
const timeoutMs = Number.isFinite(args.timeout) ? Number(args.timeout) : DEFAULT_TIMEOUT_MS;
const maxJs = Number.isFinite(args.maxJs) ? Number(args.maxJs) : DEFAULT_MAX_JS;

const findings = [];

const addFinding = (id, severity, message, details = "") => {
    findings.push({ id, severity, message, details });
};

function parseArgs(argv) {
    const out = {
        url: "",
        timeout: DEFAULT_TIMEOUT_MS,
        maxJs: DEFAULT_MAX_JS,
        help: false,
    };

    for (let i = 0; i < argv.length; i++) {
        const token = argv[i];
        if (token === "--help" || token === "-h") {
            out.help = true;
            continue;
        }
        if (token === "--url") {
            out.url = argv[i + 1] || "";
            i++;
            continue;
        }
        if (token === "--timeout") {
            out.timeout = Number(argv[i + 1]);
            i++;
            continue;
        }
        if (token === "--max-js") {
            out.maxJs = Number(argv[i + 1]);
            i++;
            continue;
        }
    }

    return out;
}

function printUsage() {
    console.log("HeliumTS pentest runner");
    console.log("");
    console.log("Usage:");
    console.log("  node scripts/helium-pentest.mjs --url <base-url> [--timeout 10000] [--max-js 10]");
    console.log("");
    console.log("Examples:");
    console.log("  node scripts/helium-pentest.mjs --url http://localhost:3000");
    console.log("  node scripts/helium-pentest.mjs --url https://staging.example.com --timeout 12000 --max-js 12");
}

function normalizeBaseUrl(raw) {
    const url = new URL(raw);
    return url.origin;
}

function makeUrl(pathname) {
    return new URL(pathname, baseUrl).toString();
}

async function fetchWithTimeout(url, options = {}) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);

    try {
        const response = await fetch(url, {
            ...options,
            redirect: "follow",
            signal: controller.signal,
        });
        return response;
    } finally {
        clearTimeout(timeout);
    }
}

async function readTextSafe(response) {
    try {
        return await response.text();
    } catch {
        return "";
    }
}

function severityScore(sev) {
    if (sev === "high") {
        return 3;
    }
    if (sev === "medium") {
        return 2;
    }
    if (sev === "low") {
        return 1;
    }
    return 0;
}

function printStep(title) {
    console.log(`\n[check] ${title}`);
}

function printOk(message) {
    console.log(`  ✓ ${message}`);
}

function printWarn(message) {
    console.log(`  ! ${message}`);
}

function printFail(message) {
    console.log(`  ✗ ${message}`);
}

function containsSecretLikeContent(text) {
    const secretPatterns = [
        /HELIUM_SECRET/i,
        /DATABASE_URL/i,
        /API[_-]?KEY/i,
        /SECRET[_-]?KEY/i,
        /JWT[_-]?SECRET/i,
        /PRIVATE[_-]?KEY/i,
        /AWS_SECRET_ACCESS_KEY/i,
        /OPENAI_API_KEY/i,
        /STRIPE_SECRET/i,
        /=[^\n]{3,}/,
    ];

    return secretPatterns.some((pattern) => pattern.test(text));
}

async function checkSensitiveFileExposure() {
    printStep("Sensitive file exposure");

    const targets = [
        "/.env",
        "/.env.local",
        "/.env.production",
        "/helium.config.ts",
        "/helium.config.js",
        "/server.js",
        "/.git/HEAD",
        "/.git/config",
    ];

    for (const target of targets) {
        const url = makeUrl(target);
        let response;

        try {
            response = await fetchWithTimeout(url, { method: "GET" });
        } catch (error) {
            printWarn(`${target}: request error (${String(error)})`);
            addFinding("sensitive-file-request-error", "low", `Request error while checking ${target}`, String(error));
            continue;
        }

        const contentType = response.headers.get("content-type") || "";
        const body = await readTextSafe(response);

        const isNotFoundLike = [403, 404, 405].includes(response.status);
        const isHtmlFallback = contentType.includes("text/html");

        if (isNotFoundLike || (response.status === 200 && isHtmlFallback && !containsSecretLikeContent(body))) {
            printOk(`${target}: not directly exposed (${response.status})`);
            continue;
        }

        if (response.status === 200 && containsSecretLikeContent(body)) {
            printFail(`${target}: possible sensitive content exposure (HTTP 200)`);
            addFinding("sensitive-file-exposed", "high", `Possible sensitive file exposure at ${target}`, `Status ${response.status}, content-type: ${contentType}`);
            continue;
        }

        if (response.status === 200) {
            printWarn(`${target}: returns HTTP 200 (inspect manually)`);
            addFinding("sensitive-file-unexpected-200", "medium", `Sensitive path returned HTTP 200 at ${target}`, `content-type: ${contentType}`);
            continue;
        }

        printWarn(`${target}: unexpected status ${response.status}`);
        addFinding("sensitive-file-unexpected-status", "low", `Unexpected status at ${target}`, `Status ${response.status}`);
    }
}

async function checkRefreshTokenEndpoint() {
    printStep("Refresh token endpoint hardening");

    const endpoint = makeUrl("/__helium__/refresh-token");

    const getResp = await fetchWithTimeout(endpoint, { method: "GET" });
    if (getResp.status === 405) {
        printOk("GET /__helium__/refresh-token is blocked (405)");
    } else {
        printWarn(`GET /__helium__/refresh-token returned ${getResp.status} (expected 405)`);
        addFinding("refresh-get-method", "medium", "Refresh token endpoint accepts unexpected method", `HTTP ${getResp.status}`);
    }

    const postNoHeaderResp = await fetchWithTimeout(endpoint, { method: "POST" });
    if (postNoHeaderResp.status === 403) {
        printOk("POST /__helium__/refresh-token requires anti-CSRF header");
    } else {
        printWarn(`POST without X-Requested-With returned ${postNoHeaderResp.status} (expected 403)`);
        addFinding("refresh-missing-header", "medium", "Refresh token endpoint may not enforce X-Requested-With", `HTTP ${postNoHeaderResp.status}`);
    }

    const postWithHeaderResp = await fetchWithTimeout(endpoint, {
        method: "POST",
        headers: {
            "X-Requested-With": "XMLHttpRequest",
        },
    });

    let token = "";
    if (postWithHeaderResp.status === 200) {
        let parsed;
        try {
            parsed = await postWithHeaderResp.json();
        } catch {
            parsed = null;
        }

        token = typeof parsed?.token === "string" ? parsed.token : "";
        const tokenLooksValid = /^\d+\.[a-f0-9]+$/i.test(token);

        if (tokenLooksValid) {
            printOk("POST with X-Requested-With returns a valid-looking token");
        } else {
            printWarn("Refresh token response format is unexpected");
            addFinding("refresh-token-format", "low", "Refresh token format is unexpected", JSON.stringify(parsed));
        }
    } else {
        printWarn(`POST with X-Requested-With returned ${postWithHeaderResp.status} (expected 200)`);
        addFinding("refresh-token-unavailable", "medium", "Unable to obtain refresh token", `HTTP ${postWithHeaderResp.status}`);
    }

    return token;
}

async function checkRpcTokenEnforcement(token) {
    printStep("RPC endpoint token enforcement");

    const endpoint = makeUrl("/__helium__/rpc");

    const noTokenResp = await fetchWithTimeout(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/octet-stream" },
        body: "x",
    });

    if (noTokenResp.status === 401) {
        printOk("POST /__helium__/rpc rejects missing token (401)");
    } else {
        printWarn(`POST /__helium__/rpc without token returned ${noTokenResp.status} (expected 401)`);
        addFinding("rpc-no-token", "high", "RPC endpoint did not reject missing token", `HTTP ${noTokenResp.status}`);
    }

    const badTokenResp = await fetchWithTimeout(endpoint, {
        method: "POST",
        headers: {
            "Content-Type": "application/octet-stream",
            "X-Helium-Token": "invalid.token",
        },
        body: "x",
    });

    if (badTokenResp.status === 401) {
        printOk("POST /__helium__/rpc rejects invalid token (401)");
    } else {
        printWarn(`POST /__helium__/rpc with invalid token returned ${badTokenResp.status} (expected 401)`);
        addFinding("rpc-invalid-token", "high", "RPC endpoint did not reject invalid token", `HTTP ${badTokenResp.status}`);
    }

    if (token) {
        const largePayload = "A".repeat(1_200_000);
        const largeResp = await fetchWithTimeout(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/octet-stream",
                "X-Helium-Token": token,
            },
            body: largePayload,
        });

        if (largeResp.status === 413) {
            printOk("RPC endpoint enforces body size limit (413)");
        } else {
            printWarn(`Large RPC payload returned ${largeResp.status} (expected 413)`);
            addFinding("rpc-max-body", "medium", "RPC endpoint may not enforce body size limits", `HTTP ${largeResp.status}`);
        }
    } else {
        printWarn("Skipped large payload test: no refresh token available");
        addFinding("rpc-max-body-skipped", "low", "Could not run large payload RPC test", "No token from refresh-token endpoint");
    }
}

function extractScriptUrls(html, origin) {
    const scriptUrls = new Set();
    const scriptSrcRegex = /<script[^>]+src=["']([^"']+)["'][^>]*>/gi;
    let match = null;

    while ((match = scriptSrcRegex.exec(html)) !== null) {
        const src = match[1];
        if (!src) {
            continue;
        }
        try {
            const url = new URL(src, origin).toString();
            scriptUrls.add(url);
        } catch {
            // Ignore malformed script URL
        }
    }

    return Array.from(scriptUrls);
}

async function checkClientBundleLeakage() {
    printStep("Client bundle secret leakage scan");

    const homepageResp = await fetchWithTimeout(makeUrl("/"), { method: "GET" });
    const homepage = await readTextSafe(homepageResp);

    if (!homepageResp.ok || !homepage) {
        printWarn("Could not fetch homepage for bundle inspection");
        addFinding("bundle-homepage-unavailable", "low", "Could not fetch homepage for client bundle scan", `HTTP ${homepageResp.status}`);
        return;
    }

    const scripts = extractScriptUrls(homepage, baseUrl).slice(0, maxJs);

    if (scripts.length === 0) {
        printWarn("No script URLs found on homepage");
        addFinding("bundle-no-scripts", "low", "No scripts found on homepage", "Manual inspection recommended");
        return;
    }

    const secretNameRegex = /(HELIUM_SECRET|DATABASE_URL|API[_-]?KEY|SECRET[_-]?KEY|JWT[_-]?SECRET|PRIVATE[_-]?KEY|AWS_SECRET_ACCESS_KEY|OPENAI_API_KEY|STRIPE_SECRET)/i;
    const nonPublicMetaEnvRegex = /import\.meta\.env\.(?!HELIUM_PUBLIC_)[A-Z0-9_]+/g;

    for (const scriptUrl of scripts) {
        const resp = await fetchWithTimeout(scriptUrl, { method: "GET" });
        const body = await readTextSafe(resp);

        if (!resp.ok || !body) {
            printWarn(`Could not inspect ${scriptUrl} (HTTP ${resp.status})`);
            addFinding("bundle-script-unavailable", "low", "Could not inspect client script", `${scriptUrl} (HTTP ${resp.status})`);
            continue;
        }

        const hasSecretName = secretNameRegex.test(body);
        const nonPublicMetaEnvMatches = body.match(nonPublicMetaEnvRegex) || [];

        if (hasSecretName || nonPublicMetaEnvMatches.length > 0) {
            printFail(`Potential secret leak indicators in ${scriptUrl}`);
            addFinding(
                "bundle-secret-indicator",
                "high",
                "Potential secret indicators found in client bundle",
                `${scriptUrl} | non-public import.meta.env refs: ${nonPublicMetaEnvMatches.join(", ") || "none"}`,
            );
            continue;
        }

        printOk(`No obvious secret indicators in ${scriptUrl}`);
    }
}

function printSummary() {
    console.log("\n=== Summary ===");

    if (findings.length === 0) {
        console.log("PASS: No findings detected by this pentest.");
        console.log("Exit code: 0");
        return 0;
    }

    const sorted = [...findings].sort((a, b) => severityScore(b.severity) - severityScore(a.severity));

    let high = 0;
    let medium = 0;
    let low = 0;

    for (const finding of sorted) {
        if (finding.severity === "high") {
            high++;
        } else if (finding.severity === "medium") {
            medium++;
        } else {
            low++;
        }
    }

    console.log(`Findings: high=${high}, medium=${medium}, low=${low}`);
    for (const finding of sorted) {
        console.log(`- [${finding.severity.toUpperCase()}] ${finding.message}`);
        if (finding.details) {
            console.log(`    ${finding.details}`);
        }
    }

    const exitCode = high > 0 || medium > 0 ? 1 : 0;
    console.log(`Exit code: ${exitCode}`);
    return exitCode;
}

async function run() {
    console.log("HeliumTS pentest runner");
    console.log(`Target: ${baseUrl}`);
    console.log(`Timeout: ${timeoutMs}ms`);
    console.log(`Max bundle scripts inspected: ${maxJs}`);

    try {
        await checkSensitiveFileExposure();
        const token = await checkRefreshTokenEndpoint();
        await checkRpcTokenEnforcement(token);
        await checkClientBundleLeakage();
    } catch (error) {
        addFinding("runner-error", "medium", "Pentest runner failed unexpectedly", String(error));
    }

    const exitCode = printSummary();
    process.exit(exitCode);
}

await run();
